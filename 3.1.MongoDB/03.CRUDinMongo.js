//
//   ðŸ”´ðŸ”´  CRUD operations in MONGODB ðŸ”´ðŸ”´

// Before proceeding further we must be wondering why we do all this stuff on terminal
// and not on vscode as we have done so far and how  does this relates to our express application.
// that we built in the last section in the Natour-app.

// The answer for that is that right now I want you to learn the absolute fundamentals of mongoDB
// without the context of any application completely outside the NodeJs. because
// in theory we could use MongoDB with any other language or any other framework it
// doesnt have to be NodeJs. so its actually good for us to leearn MongoDB standing completely on its own
// without the context of any other language.

// and later on will connect a mongoDB database with our application. so in the next section
// we can then actually start working with database. inside our express applicaiton
// and by then we will use a MongoDB driver just for Node Express so we can use more Javscript
// language to interact with our MongoDB database.

//                        ðŸ”´ Create Operation :ðŸ”´

// So in the lastTime we created a new database a new collection inside called Tours.
// and then one new document in there, and to do that we used insertOne().
// But now lets actually create two documents at the same time. so that works like this.

//ðŸ”˜ db.collectionName.insertMany([{},{}])

// natours-test > db.tours.insertMany([{ name: "The Sea Explorer", price:497, rating: 4.8},{ name: "The Snow Adventurer", price: 997, rating: 4.9, difficulty: "easy"}])
// {
//   acknowledged: true,
//   insertedIds: {
//     '0': ObjectId("658af7360a5bf107cfd1f271"),
//     '1': ObjectId("658af7360a5bf107cfd1f272")
//   }
// }

// db we is again the database then .tours which is the collection where we wawnt to
// to add our new documents and then .insertMany() and insertMany is gonna accept an array of multiple
// objects. and inside that array we put 2 object using curly braces  .insertMany([{},{}]) just like this.
// and then all we have to do is fill up the empty objects.

// Also as we already discuss that MongoDB is very flexible as all the object doesn't have to be same structure
// so we can add more key-value in different object. as we can see above.
// Also we can see that the ID's are autogenerated for each document.

//ðŸ”˜ db.tours.find()

// natours-test > db.tours.find()
// [
//   {
//     _id: ObjectId("658aee67afed284bc51e3cbc"),
//     name: 'The Forest Hiker',
//     price: 297,
//     rating: 4.7
//   },
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f271"),
//     name: 'The Sea Explorer',
//     price: 497,
//     rating: 4.8
//   },
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f272"),
//     name: 'The Snow Adventurer',
//     price: 997,
//     rating: 4.9,
//     difficulty: 'easy'
//   }
// ]

// Just to make sure it is created we check that usign above command. so here indeed we have
// our 2 document with 1 from the last lecture. where we created our first DB.

//       ðŸ”´ Querying (Reading) Documents

//ðŸ”¸Querying for data in a database is one of the most important operations that we have
// in databases. so lets now take a look at a couple of query operators in mongoDB starting with
// the simple ones and then moving on to some really complex queries.

// The easiest way to basically query for all the document in a certain collection is to
// to just use find() without passing anything in there. so thats what we were doing until
// this point and so it gives us result with all the documents that are in a certain collection
// basically without any searching criteria.

//ðŸ”˜ db.collectionName.find()

// But Now lets say that we actually only want one tour and we already know its name
// so we can search for that tour using the name that we know and so, we use the following
// command but this time we're gonna pass in a filter object, so again we need an object in
// here and so you start to see now that in mongoDB really everything works with object
// so inside this object we pass in the filter, basically the search criteria that we want to search for.
// we simply set the name to the tourName that we want to search for and thats it. so that is our search criteria
// for this search filter and now we get that document.

//ðŸ”˜ db.tours.find({search criteria})

// natours-test > db.tours.find({ name: "The Forest Hiker"})
// [
//   {
//     _id: ObjectId("658aee67afed284bc51e3cbc"),
//     name: 'The Forest Hiker',
//     price: 297,
//     rating: 4.7
//   }
// ]

// we can use this to search something else as well like say for we want a document with difficulty easy.

// natours-test > db.tours.find({ difficulty : "easy"})
// [
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f272"),
//     name: 'The Snow Adventurer',
//     price: 997,
//     rating: 4.9,
//     difficulty: 'easy'
//   }
// ]

//ðŸ”¸Now lets take it a bit next level, now we want to search document with price less than 500
//  lets see some advance query operator. lte stands for less than equal operator

//ðŸ”˜ $lte = less than equal to
//ðŸ”˜ $lt  = less than
//ðŸ”˜  db.tours.find({ price: {$lte: 500}})

// natours-test> db.tours.find({ price: {$lte: 500}})
// [
//   {
//     _id: ObjectId("658aee67afed284bc51e3cbc"),
//     name: 'The Forest Hiker',
//     price: 297,
//     rating: 4.7
//   },
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f271"),
//     name: 'The Sea Explorer',
//     price: 497,
//     rating: 4.8
//   }
// ]

// Now this looks very weird but this is how we use query operator in mongoDB.
// Now here it say search document where price is less than equal 500.
// also this ($) is special sign that is reserved in mongoDB for its operators.
// so whenever we see this dollar sign here in mongoDB, we know its a mongo operator.

//ðŸ”¸lets search for two search criteria at the same time, so what I want to do next is to
//  search for documents less or equal to 500 but also the rating greater or equal to 4.8

//ðŸ”˜$gte = greater than equal to
//ðŸ”˜$gt = greater than
//ðŸ”˜db.tours.find({ criteria1, criteria2 })

// natours-test > db.tours.find({ price: {$lte: 500}, rating:{$gte:4.8} })
// [
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f271"),
//     name: 'The Sea Explorer',
//     price: 497,
//     rating: 4.8
//   }
// ]

// So we get the result as we expected above is the only document which meets both the criteria we mentioned.

//ðŸ”¸ Lets take it further and see OR operator in mongoDB.
// SO Or query checks 2 condition and return the document based on whichever is true.
// it takes an array inside we define our 2 condition.

//ðŸ”˜ db.tours.find({ $or: [{ price: {$lte: 500}}, {rating: {$gte: 4.8}} ] })

// natours-test> db.tours.find({ $or:[ {price: {$lte: 500}}, {rating:{$gte:4.8}} ] })
// [
//   {
//     _id: ObjectId("658aee67afed284bc51e3cbc"),
//     name: 'The Forest Hiker',
//     price: 297,
//     rating: 4.7
//   },
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f271"),
//     name: 'The Sea Explorer',
//     price: 497,
//     rating: 4.8
//   },
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f272"),
//     name: 'The Snow Adventurer',
//     price: 997,
//     rating: 4.9,
//     difficulty: 'easy'
//   }
// ]

// all of the above documents fullfill our given OR criteria.
// To recap here we start with the OR operator and the OR operator accepts an array
// of condition so thats why we then create this array here and this array will then
// contain one object for each of our filters basically. so want either of this to be true.

// lets make some changes in the OR operator to see different results

// ðŸ”˜ db.tours.find({ $or:[ {price: {$gt: 500}}, {rating:{$gte:4.8}} ] })

// natours-test> db.tours.find({ $or:[ {price: {$gt: 500}}, {rating:{$gte:4.8}} ] })
// [
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f271"),
//     name: 'The Sea Explorer',
//     price: 497,
//     rating: 4.8
//   },
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f272"),
//     name: 'The Snow Adventurer',
//     price: 997,
//     rating: 4.9,
//     difficulty: 'easy'
//   }
// ]

//ðŸ”¸One more thing that besides our filter object, so this one { $or:[ {price: {$gt: 500}}, {rating:{$gte:4.8}} ] }
// we can also pass in an object for projection.
// SO what projection means is that we simply want to select some of the fields in the output
// It is very simple all we have to do is for example: say name equals to one.
// so {name: 1} means that we only want the name to be in the output and so that's why
// we set name to one. all the others properties are not gonna appear in this case.

//ðŸ”˜db.tours.find({ $or: [{Or criteria1}, {Or criteria2}] }, {projection})

// natours-test> db.tours.find({ $or:[ {price: {$gt: 500}}, {rating:{$gte:4.8}} ] }, {name:1})
// [
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f271"),
//     name: 'The Sea Explorer'
//   },
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f272"),
//     name: 'The Snow Adventurer'
//   }
// ]

// Indeed we have the name and no longer all these other properties

// ðŸ”´ Updating Documents

// So this one is similar to insertOne() that we use to create a new document
// as there is also updateMany() jsut like insertMany(). now how does updateOne()
// works first we want to select the document that we want to update and secondcwe need
// we need to pass in the data that should be updated, so the first argument is basically
// a filter object which we want to update and the second object is the what need to specify
// is what we actually want to update.
// SO in the second object we use $set operator. again we use an operator in the updateOne()
// and after $set : {create a object} and set the document that we want to update and set.

//ðŸ”˜ $set  = Set is used to set the updated document in the predefined object
//ðŸ”˜ db.collectionName.updateOne()

// natours-test > db.tours.updateOne({name: "The Snow Adventurer"}, { $set : {price: 597}})
// {
//   acknowledged: true,
//   insertedId: null,
//   matchedCount: 1,
//   modifiedCount: 1,
//   upsertedCount: 0
// }

// And now this updated our tours collections document. also an important thing
// if this query this one{name: "The Snow Adventurer"} would have selected multiple
// documents then only the first one would have been updated.
// Therefore if we already know that our query is gonna match multiple documents
// then we should use updateMany() instead of updateOne()
// Lets check if the above updation actually workds or not.

// natours-test > db.tours.find()
// [
//   {
//     _id: ObjectId("658aee67afed284bc51e3cbc"),
//     name: 'The Forest Hiker',
//     price: 297,
//     rating: 4.7
//   },
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f271"),
//     name: 'The Sea Explorer',
//     price: 497,
//     rating: 4.8
//   },
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f272"),
//     name: 'The Snow Adventurer',
//ðŸ”¸  price: 597,
//     rating: 4.9,
//     difficulty: 'easy'
//   }
// ]

// indeed it worked so we updated a document that already existed so the price was already
// there and we simply set it to a new value but we can also createe new properties.
// and set these to new values. and it actually works in the same way but lets see.

//ðŸ”¸Now we want to find the premium tours and give them a premium field set to true.
// what are premium tour? so the tours we want should have a price greater than 500
// and ratings greater or equal to 4.8, so these are the premium tours.

// natours-test > db.tours.find({price: {$gt: 500}, rating: {$gte:4.8}})
// [
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f272"),
//     name: 'The Snow Adventurer',
//     price: 597,
//     rating: 4.9,
//     difficulty: 'easy'
//   }
// ]

// Here we have our result that has premium price and rating. in this case we have only one result
// we might have multiple results so lets use updateMany()

// it takes the filter object which consist the document that we find using find() method
// and and second object it takes that we actually want to update, so here we us the
// $set operator to update the previous document and if there is none then it simply creates one for us.
// just like use. query

//ðŸ”˜ db.collectionName.updateMany({search query}, {set query})

// natours-test> db.tours.updateMany({ price: {$gt:500}, rating: {$gte:4.8}}, { $set: {premium: true}})
// {
//   acknowledged: true,
//   insertedId: null,
//   matchedCount: 1,
//   modifiedCount: 1,
//   upsertedCount: 0
// }

// Ans just to check it and make sure our updation actually happened.

// natours-test> db.tours.find()
// [
//   {
//     _id: ObjectId("658aee67afed284bc51e3cbc"),
//     name: 'The Forest Hiker',
//     price: 297,
//     rating: 4.7
//   },
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f271"),
//     name: 'The Sea Explorer',
//     price: 497,
//     rating: 4.8
//   },
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f272"),
//     name: 'The Snow Adventurer',
//     price: 597,
//     rating: 4.9,
//     difficulty: 'easy',
//     premium: true
//   }
// ]

// and here in the last one we have got our premium as true. in this case if there would have
// mulitple document matching the same query and conditions then all of them would have been updated.
// so thats how we update doc atleast partially so with .updateMany() or updateOne() we
// usually only updates parts of the document but.

//ðŸ”¸we can also completely replace the content of the document. and for that
// we use .replaceOne(). it also takes 2 object the first one is the search query and then new data that
// we want to replace

//ðŸ”˜ db.tours.replace({searchQuery}, {newData that we want to replace})

//ðŸ”¸ so just like that we have completed 3 of our CRUD operations including
//  creating , Reading and Updating now its time for the Delete operation.

//ðŸ”¸Finally we have our Delete operation, so just like before we have deleteOne()
// to delete single document and deleteMany() to delete multiple documents at the
// same time. and just like before the deleteOne() will only work for the first
// document matching your query, and deleteMany() will offcourse work for all the
// documents matching your query.
// so will delete all our tours with rating less than 4.8, but if we had multiple
// tours with that condition then all of them would be deleted. as here we want to
// to delete all the tours matching the criteria we use deleteMany()

//ðŸ”˜.deleteOne()

//ðŸ”˜ db.tours.deleteMany({condition})

// natours-test> db.tours.deleteMany({ rating: {$lt: 4.8}})
// {
//    acknowledged: true,
//    deletedCount: 1
// }

// So it deleted one document. now to comfirm lets check all document. we are only
// remained with 2 documents

// natours-test > db.tours.find()
// [
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f271"),
//     name: 'The Sea Explorer',
//     price: 497,
//     rating: 4.8
//   },
//   {
//     _id: ObjectId("658af7360a5bf107cfd1f272"),
//     name: 'The Snow Adventurer',
//     price: 597,
//     rating: 4.9,
//     difficulty: 'easy',
//     premium: true
//   }
// ]

//ðŸ”¸Now if we wanted to delete all of the documents then we would have use.
//  here empty object indicates all the document, as it has nothing to match with it will delete everything.
//  we must be really cautious using this query as it can delete all the doc and there is no coming back
//  unless we have backup data.

//ðŸ”˜ db.tours.deleteMany({})

//ðŸ”˜so rather than using terminal we can use a app called compass to run mondodb command init
// it is a GUI provided by mongodb.
